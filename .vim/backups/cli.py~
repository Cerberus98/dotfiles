#
# Copyright 2017, Cisco Systems
# All Rights Reserved.
#

import datetime
import logging
import os
import pipes
import re
import sys
import time

import click
import dateutil.parser
import prettytable
import sh

from harmonium import core
from harmonium import exc
from harmonium import ssh

LOG = logging.getLogger('harmonium')
TERMINAL_WIDTH = 120
CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'], max_content_width=TERMINAL_WIDTH)
VERSION = 0.1

pass_env = click.make_pass_decorator(core.Environment, ensure=True)


@click.group(context_settings=CONTEXT_SETTINGS)
@click.version_option(version=VERSION)
@click.option('--debug/--no-debug', default=None, help='Enables logging and output to stdout.')
@pass_env
def main(env, debug=None):
    """
    \b
     _____                       _           
    |  |  |___ ___ _____ ___ ___|_|_ _ _____ 
    |     | .'|  _|     | . |   | | | |     |
    |__|__|__,|_| |_|_|_|___|_|_|_|___|_|_|_|

    Harmony Deployments Manager

    Enable autocomplete in bash and zsh:

        autoload bashcompinit && bashcompinit # For zsh only.
        eval "$(_HARMONIUM_COMPLETE=source harmonium)"
    """
    env.debug = env.config.debug(arg=debug)
    if debug:
        LOG.debug('Config Settings:\n%s\n',
                  '\n'.join(['%s=%s' % (opt.name.upper(), opt()) for opt in env.config.options]))


@main.command()
@pass_env
def whoami(env):
    """List the current user of this application"""
    click.echo(env.username)


@main.group()
def reserve():
    """Reserve a Proxmox or Baremetal cluster"""
    pass


def _reserve_options(f):
    f = click.option(
        '--name', '-n', metavar='RESERVATION_NAME', help='reservation identifier [defaults to a unique hex id].')(f)
    f = click.option(
        '--control',
        '-c',
        'control_machine_count',
        metavar='CONTROL_MACHINE_COUNT',
        default=3,
        show_default=True,
        type=click.IntRange(1, 16),
        help='Number of Control machines to allocate.')(f)
    # TODO: bring this option back once https://metacloud.jira.com/browse/GALACTIC-1646 lands
    # f = click.option(
    #     '--domain',
    #     '-d',
    #     'domain_machine_count',
    #     metavar='DOMAIN_MACHINE_COUNT',
    #     default=0,
    #     show_default=True,
    #     type=click.IntRange(0, 16),
    #     help='Number of Domain machines to allocate.')(f)
    f = click.option(
        '--tags',
        '-t',
        metavar='TAG1,TAG2,TAG3...',
        default=None,
        callback=lambda _ctx, _param, value: value.split(',') if value else '',
        help='Comma separated string specifying tags of an existing proxmoxhost or baremetal cluster [see "harmonium audit inventory"].'
    )(f)
    return f


@reserve.command()
@_reserve_options
@pass_env
def proxmox(env, name, control_machine_count, tags):
    machine_count = {'control': control_machine_count}  #, 'domain': domain_machine_count}
    reservation = env.create_reservation(machine_count=machine_count, reservation_type='proxmox', name=name, tags=tags)
    LOG.info('Reserved "%s".', reservation['name'])


@reserve.command()
@_reserve_options
@pass_env
def baremetal(env, name, control_machine_count, tags):
    machine_count = {'control': control_machine_count}  #, 'domain': domain_machine_count}
    reservation = env.create_reservation(
        machine_count=machine_count, reservation_type='baremetal', name=name, tags=tags)
    LOG.info('Reserved "%s".', reservation['name'])


def _from_utcnow_total_minutes(timestamp):
    return int((datetime.datetime.utcnow() - dateutil.parser.parse(timestamp)).total_seconds() / 60)


@main.command()
@click.option(
    '--older-than',
    '-o',
    type=click.IntRange(0, float('inf')),
    metavar='MINUTES',
    help='Remove reservations that are --older-than (specified in minutes).')
@click.option(
    '--last-status-update',
    '-l',
    type=click.IntRange(0, float('inf')),
    metavar='MINUTES',
    help='Remove reservations based on deployment --last-status-update (specified in minutes).')
@click.option(
    '--status-re',
    '-s',
    metavar='REGEX',
    callback=lambda _c, _p, val: re.compile(val) if val else None,
    help='Remove reservations by matching --status-re (a regex) with the deployment status.')
@pass_env
def purge(env, older_than, last_status_update, status_re):
    """Remove reservations based on age, last modified time or deployment status."""
    if last_status_update is not None and older_than is not None:
        raise exc.DieWithError('Either --last-status-update or --older-than can be specified, but not both.')
    elif last_status_update is None and older_than is None and status_re is None:
        raise exc.DieWithError('Must specify either --older-than, --last-status-update or --status.')

    reservations = env.get_reservations()
    for res in reservations:
        name = res.name
        status = res.deployment_status
        timestamp = None
        reason = None
        limit = None

        if older_than is not None:
            timestamp = res.created
            reason = '(based off --older-than)'
            limit = older_than
        elif last_status_update is not None:
            timestamp = res.last_status_update
            reason = '(based off --last-status-update)'
            limit = last_status_update

        LOG.debug(
            'Reservation "%s" is "%d" minutes old with deployment status "%s", last status update occurred "%d" minutes ago.',
            name, _from_utcnow_total_minutes(res.created), status, _from_utcnow_total_minutes(res.last_status_update))

        limit_match = _from_utcnow_total_minutes(timestamp) >= limit if limit is not None else False
        status_match = status_re.match(status) if status_re is not None else False
        msg = None
        if limit_match and status_match:
            msg = 'Removing "%s" because the deployment status matches pattern "%s" and is older than "%d" minutes %s.' % (
                name, status_re.pattern, limit, reason)
        elif limit_match and status_re is None:
            msg = 'Removing "%s" because it is older than "%d" minutes %s.' % (name, limit, reason)
        elif status_match and not limit_match:
            msg = 'Removing "%s" because the deployment status matches pattern "%s".' % (name, status_re.pattern)

        if msg is not None:
            LOG.info(msg)
            release(env, name)


def _show_list_options(f):
    def filter_callback(ctx, _param, filter_str):
        # --all is an eager option which is evaluated first
        if ctx.params.get('all', False) is True:
            filter_str = 'name,tags,networks,machines,created,type,deployment{status,last_status_update,last_config_update,iso_url}'
        return filter_str

    f = click.option(
        '--filter',
        '-f',
        'filter_csv',
        metavar='"prop,prop{subprop{...}}"',
        default=None,
        callback=filter_callback,
        help='Filter properties [e.g --filter "name,machines{interfaces{name,ip}}"].', )(f)
    f = click.option(
        '--all', '-a', is_flag=True, is_eager=True, help='Displays all properties [except "deployment{config}""].')(f)
    return f


def tabulate_reservation_data(reservations_or_res):
    if isinstance(reservations_or_res, dict):
        reservations_or_res = [reservations_or_res]

    out_table = prettytable.PrettyTable([''], header=False, border=True)
    out_table.align = 'l'
    for reservation in reservations_or_res:
        res_table = prettytable.PrettyTable([''], border=True, header=False)
        res_table.align = 'l'
        res_table.add_row([core.yamlify(reservation)])
        out_table.add_row([res_table.get_string()])
    click.echo(out_table.get_string())


DEFAULT_LIST_FILTER = 'name,created,type,deployment{status,last_status_update},tags'


@main.command(
    'list',
    help="""
\b
List all reservation data
It is not recommended to --filter with "deployment{config}"
Instead, for a nicer view issue "harmonium show RESERVATION --deployment"
[NOTE] when no options are specified --filter defaults to "%s"
""" % DEFAULT_LIST_FILTER)
@_show_list_options
@pass_env
def list_(env, filter_csv, **_kwargs):
    if filter_csv is None:
        filter_csv = DEFAULT_LIST_FILTER
    reservations = env.get_reservations(
        deserialize=False, cache_fallback=env.list_fallback_cache, headers={'X-fields': filter_csv})
    if not reservations:
        click.echo('No reservations.')
    else:
        return tabulate_reservation_data(reservations)


DEFAULT_SHOW_FILTER = 'name,tags,machines{name,interfaces{name,mac,ip}},created,type,deployment{status,last_status_update,iso_url}'


@main.command(
    'show',
    help="""
\b
Show the reservation data
--deployment displays the raw config data without formatting
[NOTE] when no options are specified --filter defaults to "%s"
""" % DEFAULT_SHOW_FILTER)
@click.argument('name', metavar='RESERVATION_NAME')
@_show_list_options
@click.option('--deployment', '-d', is_flag=True, help='Show the deployment config.')
@pass_env
def show(env, name, filter_csv, deployment, **kwargs):
    if deployment:
        filter_csv = 'deployment{config}'
    elif all(v is False for v in kwargs.values()) and filter_csv is None:
        filter_csv = DEFAULT_SHOW_FILTER

    reservation = env.get_reservation(name, deserialize=False, headers={'X-fields': filter_csv})
    if not reservation:
        click.echo("No reservation named '{}' found".format(name))
        return

    if deployment:
        if 'config' in reservation['deployment']:
            click.echo(reservation['deployment']['config'])
        else:
            click.echo('null')
    else:
        click.echo(core.yamlify(reservation))


@main.command('release')
@click.argument('name', metavar='RESERVATION_NAME')
@pass_env
def release_(env, name):
    """Release a reservation"""
    return release(env, name)


def release(env, name):
    reservation = env.get_reservation(name)
    if reservation.type == 'proxmox':
        proxmox_ctl = env.proxmox_ctl(reservation)
        try:
            proxmox_ctl.cleanup(reservation.machines)
        except Exception as e:
            raise exc.DieWithError('Cleanup failed with error (reservation not released): %s\n' % str(e))

    env.delete_reservation(name)
    LOG.info('Reservation "%s" released.', name)


@main.command('dump-config')
@click.argument('name', metavar='RESERVATION_NAME')
@click.option('--output-path', '-o', type=click.Path(), help='Dump the config to this filepath.')
@click.option(
    '--template',
    '-e',
    default=None,
    show_default=True,
    help='Use an alternative template. Defaults to the built in '
    'harmonium template')
@pass_env
def dump_config(env, name, output_path, template):
    """Dump the deployment config [sparta.yaml]"""
    reservation = env.get_reservation(name)
    sparta_yaml = reservation.generate_sparta_config(template)
    if output_path:
        try:
            with open(output_path, 'w') as f:
                f.write(sparta_yaml)
        except IOError as e:
            raise exc.DieWithError(str(e))
        LOG.info('Deployment config written to "%s"', output_path)
    else:
        LOG.info(sparta_yaml)


def _generate_iso_from_isobuilder(isobuilder, base_iso, sparta_yaml, deployment_config=None):
    if deployment_config is None:
        deployment_config = os.path.join(isobuilder, 'harmonium-deploy.yaml')
        try:
            with open(deployment_config, 'w') as f:
                f.write(sparta_yaml)
        except IOError as e:
            raise exc.DieWithError(str(e))
        LOG.info('Deployment config written to "%s"', deployment_config)

    iso = os.path.join(isobuilder, 'harmonium-deploy.iso')
    try:
        sh.make(
            '-C',
            isobuilder,
            'iso',
            "ARGS=--iso-name='%s' '%s' '%s'" % (iso, base_iso, deployment_config),
            _out=sys.stdout,
            _err=sys.stderr)
    except sh.ErrorReturnCode:
        raise exc.DieWithError('Running isobuilder failed.')
    if not os.path.exists(iso):
        raise exc.DieWithError('Running isobuilder did not create %s.' % iso)
    LOG.info('Isobuilder completed successfully.')
    return iso


def _wait_for_healthy_status_or_raise(env, reservation, node_username, timeout):
    stop = datetime.datetime.utcnow() + datetime.timedelta(seconds=timeout)
    # Current assumption that baremetal nodes are accessible directly, and that proxmox hosts are not.
    proxy = None
    if reservation.node0.mgmt_driver == 'proxmox':
        proxy = ssh.Endpoint(reservation.node0.mgmt_host, env.username)
    node0_ssh_ep = ssh.Endpoint(reservation.node0.ip, node_username, proxy=proxy)

    try:
        with ssh.Connection(node0_ssh_ep, timeout=timeout, retry_wait=5) as node0_ssh:
            sleep_timeout = 10
            while True:
                if datetime.datetime.utcnow() > stop:
                    env.fail_deployment(reservation, 'Timed out waiting for cluster health to be ok or failure.')
                # Cluster health command returns 0 if ok, 1 if failure, and 2 if pending.
                result = node0_ssh.execute('harmony health')
                if result.exit_status == 0:
                    LOG.info('Cluster health is ok.')
                    break
                elif result.exit_status == 1:
                    env.fail_deployment(reservation, 'Cluster status is failure:\n%s' % result.stderr)
                elif result.exit_status == 2:
                    LOG.debug('Cluster health pending. Sleeping for %ds...', sleep_timeout)
                    LOG.debug('Pending status:\n%s', result.stderr)
                    time.sleep(sleep_timeout)
                    continue
                else:
                    env.fail_deployment(reservation, 'Unhandled exit status "%d" from cluster health command:\n%s' %
                                        (result.exit_status, result.stderr))
    except ssh.ConnectionError as e:
        env.fail_deployment(reservation, 'Timed out trying to open a ssh connection to node0. Last error: %s' % str(e))


@main.command()
@click.argument('name', metavar='RESERVATION_NAME')
@click.option(
    '--deployment-config',
    '-c',
    type=click.Path(exists=True),
    help='Deploy using this deployment config [a.k.a sparta.yaml].')
@click.option('--iso', '-i', type=click.Path(exists=True), help='Deploy using this ISO.')
@click.option('--isobuilder', '-g', type=click.Path(exists=True), help='Generate ISO using isobuilder git checkout.')
@click.option('--base-iso', '-b', type=click.Path(exists=True), help='Base ISO to use with --isobuilder.')
@click.option(
    '--timeout',
    '-t',
    default=1800,
    show_default=True,
    type=click.IntRange(1, 86400),
    help='Maximum time to wait for cluster health to stabilize.')
@click.option('--username', '-u', default='admin', show_default=True, help='Node login username.')
@click.option(
    '--template',
    '-e',
    default=None,
    show_default=True,
    help='Use an alternative template. Defaults to the built in '
    'harmonium template')
@pass_env
def deploy(env, name, deployment_config, iso, isobuilder, base_iso, timeout, username, template):
    """Deploy a reservation"""
    if iso and deployment_config:
        raise exc.DieWithError('Both --iso and --deployment-config were specified, but only one can be.')
    if iso and isobuilder:
        raise exc.DieWithError('Both --iso and --isobuilder were specified, but only one can be.')
    if (isobuilder and not base_iso) or (not isobuilder and base_iso):
        raise exc.DieWithError('Both --isobuilder and --base-iso must be specified, not just one.')

    reservation = env.get_reservation(name)
    if isobuilder and base_iso and reservation.type == 'baremetal':
        # we'd need a dedicated http server somewhere to upload the local ISOs so that cimc can mount them.
        raise exc.DieWithError('Deploying baremetal with --isobuilder is not supported at this time.')

    sparta_yaml = None
    if not iso:
        # create sparta_yaml
        if deployment_config:
            LOG.info('Loading deployment config from "%s"', deployment_config)
            with open(deployment_config, 'r') as f:
                sparta_yaml = f.read()
        else:
            LOG.info('Generating deployment config.')
            sparta_yaml = reservation.generate_sparta_config(template_path=template)

        # we have sparta_yaml now get the iso
        if isobuilder:
            LOG.info('Calling isobuilder (%s).', isobuilder)
            iso = _generate_iso_from_isobuilder(isobuilder, base_iso, sparta_yaml, deployment_config=deployment_config)
        else:
            LOG.info('Calling ISOaaS (%s).', env.isoservice_url)
            iso = env.isoservice.create_iso(sparta_yaml)

    # ready to deploy
    LOG.info('ISO: %s', iso)
    LOG.debug('Deployment config:\n%s\n', sparta_yaml)
    LOG.info('Deploying %s.', name)
    env.update_reservation_deployment(reservation.name, config=sparta_yaml, status='deploying', iso_url=iso)

    if reservation.type == 'baremetal':
        isotester_args = ('--debug', '--ip', reservation.node0.mgmt_host, '--user', reservation.node0.mgmt_username,
                          '--password', reservation.node0.mgmt_password, '--iso', iso, '--server_ip',
                          reservation.node0.ip)
        LOG.info('Calling isotester.')
        LOG.debug('Isotester args: %s', list(isotester_args))
        try:
            # TODO: the only reason to use docker command and thus sudo here, is because of cimc 3.0 support
            # within the isotester container, i.e it is currently not possible to run the imcsdk libary without
            # (Python2 version >= 2.7.9 and Openssl version >= 1.0.1) https://github.com/CiscoUcs/imcsdk/blob/master/docs/imcsdk_ug.rst#connecting-disconnecting
            # and thus we can't use isotester as pypkg directly. but there is hope, support for imcsdk is coming...
            sh.sudo.docker.run('--rm', env.isotester_container_img, *isotester_args, _fg=True)
        except sh.ErrorReturnCode as e:
            env.fail_deployment(reservation, 'Running isotester failed - %s.' % str(e))
    else:
        proxmox_ctl = env.proxmox_ctl(reservation)
        try:
            proxmox_ctl.cleanup(reservation.machines)
        except Exception as e:
            env.fail_deployment(reservation, 'Cleanup failed with error: %s\n' % str(e))
        proxmox_ctl.boot_from_installer(reservation.node0, iso)
        map(proxmox_ctl.boot_from_network, reservation.other_nodes)

    LOG.info('Waiting for cluster health to stabilize.')
    _wait_for_healthy_status_or_raise(env, reservation, username, timeout)
    env.update_reservation_deployment(reservation.name, status='deployed successfully')


def _ssh_cmdline_helper(env, name, node, identity_file):
    reservation = env.get_reservation(
        name, cache_fallback=env.ssh_fallback_cache, always_cache_for=env.ssh_always_cache)
    machine = reservation.get_machine_by_shortname(node)
    if not machine:
        raise exc.DieWithError('Node "%s" does not exist in reservation %s.' % (node, name))

    # The 'Hostname' option is used so we can use the symbolic hostname, mostly
    # so that 'ps' can easily show what host we're connected to.
    cmd = [
        'ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'UserKnownHostsFile=/dev/null', '-o', 'Hostname=%s' % machine.ip
    ]
    # Current assumption that baremetal nodes are accessible directly, and
    # that proxmox hosts are not.
    if machine.mgmt_driver == 'proxmox':
        cmd.extend(
            ['-o', 'ProxyCommand=ssh -o StrictHostKeyChecking=no -W %%h:%%p %s@%s' % (env.username, machine.mgmt_host)])
    if identity_file:
        cmd.extend(['-i', identity_file])

    return cmd


@main.command('ssh')
@click.argument('name', metavar='{RESERVATION_NAME}')
@click.argument('node', metavar='{MACHINE_SHORTNAME|USER@MACHINE_SHORTNAME}')
@click.option('--username', '-u', default='admin', show_default=True, help='Node login username.')
@click.option('--identity-file', '-i', type=click.Path(exists=True))
@click.option('--command', '-c', help='issue a command [e.g -c "kubectl get pods --all-namespaces"]')
@click.option(
    '--kubectl-pods',
    '-kp',
    is_flag=True,
    callback=lambda _ctx, _param, val: "kubectl get pods --all-namespaces" if val else False,
    help='[shortcut] issue "kubectl get pods --all-namespaces"')
@click.option(
    '--kubectl-nodes',
    '-kn',
    is_flag=True,
    callback=lambda _ctx, _param, val: "kubectl get nodes" if val else False,
    help='[shortcut] issue "kubectl get nodes"')
@click.option(
    '--kubectl-all',
    '-ka',
    is_flag=True,
    callback=lambda _ctx, _param, val: "kubectl get all --all-namespaces" if val else False,
    help='[shortcut] issue "kubectl get all --all-namespaces"')
@click.option(
    '--etcdctl-cluster-health',
    '-eh',
    is_flag=True,
    callback=lambda _ctx, _param, val: "etcdctl cluster-health" if val else False,
    help='[shortcut] issue "etcdctl cluster-health"')
@pass_env
def ssh_(env, name, node, username, command, identity_file, **cmdshortcuts):
    """SSH into a Node or issue a command"""
    # Support user@host like ssh does.
    if '@' in node:
        username, node = node.split('@', 1)

    cmd = _ssh_cmdline_helper(env, name, node, identity_file)
    cmd.append('%s@%s' % (username, node))

    shortcut = False
    for _cli_option_name, cmd_shortcut in cmdshortcuts.items():
        if isinstance(cmd_shortcut, basestring) and not shortcut:
            cmd.append(cmd_shortcut)
            shortcut = True
        elif isinstance(cmd_shortcut, basestring) and shortcut:
            raise exc.DieWithError('only one command shortcut can be specified, select one and try again: %s' %
                                   ['--%s' % cmds.replace('_', '-') for cmds, _ in cmdshortcuts.items()])

    if not shortcut and command:
        cmd.append(command)

    os.execvp('ssh', cmd)


def _normalize_rsync_pathspec(pathspec, default_username):
    if ':' in pathspec:
        hostname, _ = pathspec.split(':', 1)

        if '@' in hostname:
            _, hostname = hostname.split('@', 1)
        else:
            pathspec = '%s@%s' % (default_username, pathspec)
    else:
        hostname = None

    return pathspec, hostname


@main.command('rsync')
@click.argument('name', metavar='RESERVATION_NAME')
@click.argument('source')
@click.argument('destination')
@click.option('--username', '-u', default='admin', show_default=True, help='Node login username.')
@click.option('--identity-file', '-i', type=click.Path(exists=True))
@click.option(
    '--rsync-options', '-o', default='-av', show_default=True, help='Space separated list of options to pass to rsync.')
@click.option('--sudo/--no-sudo', default=True, show_default=True, help='Use sudo on remote end.')
@pass_env
def rsync(env, name, source, destination, username, identity_file, rsync_options, sudo):
    """Issue rsync command to a node"""
    source, src_host = _normalize_rsync_pathspec(source, username)
    destination, dst_host = _normalize_rsync_pathspec(destination, username)

    if src_host and dst_host:
        raise exc.DieWithError('Remote source with remote destination is not supported.')

    if not src_host and not dst_host:
        raise exc.DieWithError('The source or the destination must be remote.')

    node = src_host or dst_host
    ssh_cmd = _ssh_cmdline_helper(env, name, node, identity_file)

    cmd = ['rsync', '-e', ' '.join([pipes.quote(x) for x in ssh_cmd])]
    cmd.extend(rsync_options.split(' '))
    if sudo:
        cmd.append('--rsync-path=sudo rsync')
    cmd.append(source)
    cmd.append(destination)

    os.execvp('rsync', cmd)


@main.group()
def audit():
    """View the server's reservation and inventory data"""
    pass


@audit.command('reservations')
@click.option(
    '--filter',
    '-f',
    'filter_csv',
    default=None,
    metavar='"PROP,PROP{SUBPROP{...}}"',
    help='quote enclosed filter string [e.g --filter "owner,reservation{name,type,machines{name,id}}"]')
@pass_env
def reservations_(env, filter_csv):
    """Retrieve all reservation data for all users"""
    headers = {}
    if filter_csv:
        headers['X-fields'] = filter_csv
    click.echo(core.yamlify(env.client.get('audit/reservations', headers=headers).json()))


@audit.command()
@click.option(
    '--filter',
    '-f',
    'filter_csv',
    default=None,
    metavar='"PROP,PROP{SUBPROP{...}}"',
    help='quote enclosed filter string [e.g --filter "users,baremetal{name,tags},proxmox{hosts{fqdn,tags}}"]')
@click.option('--baremetal', '-b', 'list_baremetal', is_flag=True, help='list baremetal inventory only')
@click.option('--proxmox', '-p', 'list_proxmox', is_flag=True, help='list proxmox inventory only')
@click.option('--users', '-u', 'list_users', is_flag=True, help='list current users only')
@pass_env
def inventory(env, filter_csv, list_proxmox, list_baremetal, list_users):
    """Retrieve the current server inventory"""
    opt_flags = []
    if list_proxmox:
        opt_flags.append('proxmox')
    if list_baremetal:
        opt_flags.append('baremetal')
    if list_users:
        opt_flags.append('users')
    if opt_flags and filter_csv:
        raise exc.DieWithError('--filter can only be invoked by itself, but also got %s' %
                               ', '.join(['--%s' % o for o in opt_flags]))
    if opt_flags:
        filter_csv = ','.join(opt_flags)
    headers = {}
    if filter_csv:
        headers['X-fields'] = filter_csv
    click.echo(core.yamlify(env.client.get('audit/inventory', headers=headers).json()))


@main.command()
@click.argument('name', metavar='RESERVATION_NAME')
@click.argument('new_owner', metavar='NEW_OWNER')
@click.option('--old-owner', '-u', metavar='OLD_OWNER', help='If you are not the owner of the reservation.')
@pass_env
def reassign(env, name, new_owner, old_owner):
    """Reassign a reservation to another user"""
    if old_owner is None:
        old_owner = env.username
    LOG.info(env.reassign_reservation(name, new_owner, old_owner=old_owner))
