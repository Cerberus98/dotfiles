from collections import OrderedDict
import logging
import re

from flask_restplus import mask

LOG = logging.getLogger(__name__)


class MatcherMask(mask.Mask):
    """
    Parses out matching k=v pairs from a mask-like string

    Adapted from the flask_restplus mask parser, this implementation instead
    looks for matching key-value pairs and applies them to the database result
    set, only returning entries as an AND of all the match predicates, i.e. only
    entries matching EACH AND EVERY match predicate will be returned to the
    client. """

    LEXER = re.compile(r'\{|\}|\,|[\w=_:\-\*]+')

    def __init__(self, skip=False):
        self.skip = skip
        super(MatcherMask, self).__init__()

    def parse(self, mask):
        if not mask:
            return

        mask = self.clean(mask)
        fields = self
        previous = None
        stack = []

        for token in self.LEXER.findall(mask):
            LOG.debug("A" * 80)
            LOG.debug("token %s", token)
            if token == '{':
                if previous not in fields:
                    raise ParseError('Unexpected opening bracket')
                fields[previous] = MatcherMask(skip=self.skip)
                stack.append(fields)
                fields = fields[previous]
            elif token == '}':
                if not stack:
                    raise ParseError('Unexpected closing bracket')
                fields = stack.pop()
            elif token == ',':
                if previous in (',', '{', None):
                    raise ParseError('Unexpected coma')
            else:
                fields[token] = True

            LOG.debug("previous %s", previous)
            LOG.debug("A" * 80)
            previous = token

        if stack:
            raise ParseError('Missing closing bracket')

    def filter_data(self, data):
        '''
        Handle the data filtering given a parsed mask

        :param dict data: the raw data to filter
        :param list mask: a parsed mask tofilter against
        :param bool skip: whether or not to skip missing fields

        '''
        out = {}
        for field, content in self.items():
            if field == '*':
                continue
            elif isinstance(content, Mask):
                nested = data.get(field, None)
                if self.skip and nested is None:
                    continue
                elif nested is None:
                    out[field] = None
                else:
                    out[field] = content.apply(nested)
            elif self.skip and field not in data:
                continue
            else:
                out[field] = data.get(field, None)

        if '*' in self.keys():
            for key, value in data.items():
                if key not in out:
                    out[key] = value
        return out
