#
# Copyright 2017, Cisco Systems
# All Rights Reserved.
#

import base64
import errno
import json
import os
import urlparse

import paramiko
import requests

from harmonium import config
from harmonium import exc

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)


class LoginError(exc.HarmoniumException):
    pass


class TranquilityClient(object):
    def __init__(self, baseurl, username, verify_ssl=True, api_version='v1'):
        self.server_url = urlparse.urljoin(baseurl, api_version + '/')
        self.api_version = api_version
        self.username = username
        self.verify_ssl = verify_ssl
        self.cookie = None

        try:
            with open(config.TRANQUILITY_SESSION_FILE, 'r') as f:
                self.cookie = f.read()
        except IOError as e:
            if e.errno != errno.ENOENT:
                raise

    # So we can bubble up consistent exceptions.
    def _requests(self, method, *args, **kw):
        try:
            f = getattr(requests, method)
            return f(*args, verify=self.verify_ssl, **kw)
        except requests.exceptions.RequestException as e:
            raise LoginError('Error connecting to %s: %s' % (self.server_url, str(e)))

    def login(self):
        data = {'username': self.username}
        res = self._requests('post', urlparse.urljoin(self.server_url, 'login'), data=json.dumps(data))

        if res.status_code != 401:
            raise LoginError('Unhandled authentication error (%d): %s' % (res.status_code, res.text))

        res_json = None
        try:
            res_json = res.json()
        except ValueError:
            pass
        if not res_json:
            raise LoginError('Authentication failed:  Server response is not JSON.')

        challenge = res_json.get('challenge')
        if not challenge:
            raise LoginError('Authentication failed:  Server did not return challenge.')

        data = {'username': self.username, 'challenge': challenge, 'signatures': []}

        agent = paramiko.agent.Agent()
        keys = agent.get_keys()
        for key in keys:
            data['signatures'].append(base64.b64encode(str(key.sign_ssh_data(challenge))))

        if not data['signatures']:
            raise LoginError('Authentication failed:  No available private keys.')

        res = self._requests('post', urlparse.urljoin(self.server_url, 'login'), data=json.dumps(data))

        if res.status_code == 401:
            raise LoginError('Authentication failed:  Server did not accept any signed challenge.')

        if res.status_code != 200:
            raise LoginError('Unhandled authentication error (%d): %s' % (res.status_code, res.text))

        self.cookie = res.headers.get('Set-Cookie')
        if not self.cookie:
            raise LoginError('Authentication successful, but server did not return cookie.')

        if not len(self.cookie) > 1:
            raise LoginError('Server returned empty cookie.')

        try:
            os.makedirs(config.HOMEDIR, mode=0700)
        except OSError as e:
            if e.errno != errno.EEXIST:
                raise

        with open(config.TRANQUILITY_SESSION_FILE, 'w') as f:
            f.write(self.cookie)

    def _router(self, meth, rpath, data=None, **kwargs):
        url = urlparse.urljoin(self.server_url, rpath)
        if not self.cookie:
            self.login()

        if data is not None:
            data = json.dumps(data)

        headers = kwargs.get('headers', {})
        headers['Cookie'] = self.cookie
        kwargs['headers'] = headers
        res = self._requests(meth, url, data=data, **kwargs)

        if res.status_code == 401:
            self.login()
            kwargs['headers']['Cookie'] = self.cookie
            res = self._requests(meth, url, data=data, **kwargs)
            if res.status_code == 401:
                # We just got this cookie, it should have worked.
                raise LoginError('Server returned 401 with fresh cookie.')

        return res

    def get(self, rpath, **kwargs):
        return self._router('get', rpath, **kwargs)

    def delete(self, rpath, **kwargs):
        return self._router('delete', rpath, **kwargs)

    def post(self, rpath, data, **kwargs):
        return self._router('post', rpath, data=data, **kwargs)

    def put(self, rpath, data, **kwargs):
        return self._router('put', rpath, data=data, **kwargs)
