#!/usr/bin/env python
#pylint: disable=E1120,E1121,E1123


import base64
import contextlib
import errno
import glob
import os
import shutil
import stat
import sys
import tempfile
import yaml

import click
import jinja2
import sh


# find an appropriate command we can use for building ISOs
# and bail out if not possible
try:
    from sh import mkisofs as iso_builder
except ImportError:
    try:
        from sh import genisoimage as iso_builder
    except ImportError:
        sys.error.write('ERROR: Unable to find mkisofs or genisoimage. Please '
                        'install one to continue.\n')
        sys.exit(1)

try:
    from sh import openssl
except ImportError:
    sys.error.write("ERROR: Unable to import openssl.\n")
    sys.exit(1)


TEMPLATE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates')
OVERLAY_DIR = "overlay/etc/"
OUTPUT_DIR = os.path.join(OVERLAY_DIR, "sparta")
CONFIG_YAML = "config.yaml"


class MakeISOError(RuntimeError):
    def __init__(self, **kwargs):
        super(MakeISOError, self).__init__(self.message % kwargs)
        self.msg = self.message % kwargs


class ConfigNotFound(MakeISOError):
    message = "Config file %(config)s not found"


class TemplatesNotFound(MakeISOError):
    message = "Template path %(templates)s not found"


class TemplateRenderError(MakeISOError):
    message = "Templates could not be rendered: %(exc)s"


class TemplateWriter(object):
    def __init__(self, config, templates):
        self._config_data = dict()
        if not os.path.exists(config):
            raise ConfigNotFound(config=config)
        if not os.path.exists(templates):
            raise TemplatesNotFound(templates=templates)
        with open(config) as f:
            self._config_data = yaml.load(f)

        if self._config_data is not None and self._config_data.get('global', {}).get('ssh_pubkey'):
            ssh_pubkey_path = os.path.expanduser(self._config_data['global']['ssh_pubkey'])

            with open(ssh_pubkey_path) as f:
                ssh_pubkey=f.read().rstrip()

            for user in self._config_data['users']:
                if not "authorized_keys" in self._config_data['users'][user]:
                    self._config_data['users'][user]['authorized_keys'] = []
                self._config_data['users'][user]['authorized_keys'].append(ssh_pubkey)
        else:
            print "Notice: no `ssh_pubkey` defined under `global` configuration" \
                "SSH authentication may fail"


        self._output_root = tempfile.mkdtemp()
        self._config = config
        self._templates = templates

    def write_templates(self):
        out = lambda p: os.path.join(self._output_root, p)
        # copy in config
        os.makedirs(out(OUTPUT_DIR))
        #shutil.copyfile(self._config, out('{}/{}'.format(OUTPUT_DIR, CONFIG_YAML)))
        cfg = open(out('{}/{}'.format(OUTPUT_DIR, CONFIG_YAML)), "w")
        yaml.dump(self._config_data, cfg, default_flow_style=False)
        cfg.close()

        env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(self._templates))

        # walk all files in template directory

        for root, _, files in os.walk(self._templates):
            for f in files:
                if not f.endswith('.j2'):
                    print 'skipping %s' % os.path.join(root, f)
                    continue
                # get the path under templates dir, ex: overlay/etc/kubernetes
                trimmed_path = root[len(self._templates):].lstrip('/')
                # ensure output directory for this template
                dest_dir = out(trimmed_path)
                try:
                    os.makedirs(dest_dir)
                except OSError as exc:
                    # pass if already exists, otherwise blow up
                    if exc.errno != errno.EEXIST:
                        raise
                dest_file = os.path.join(dest_dir, f).strip('.j2')
                tmpl = env.get_template(os.path.join(trimmed_path, f))
                try:
                    with open(dest_file, 'w') as df:
                        df.write(tmpl.render(self._config_data))
                except Exception, e:
                    if os.path.exists(dest_dir):
                        shutil.rmtree(dest_dir)
                    raise TemplateRenderError(exc=e)
        return self._output_root




class ISO(object):
    def __init__(self, iso):
        self._iso = iso

    def copy_to(self, dest):
        extract_cmd = '7z'
        try:
            cmd = sh.Command(extract_cmd)
        except sh.CommandNotFound:
            print ('ERROR: %s command is not found or not in your PATH. Please install '
                'it to continue.' % extract_cmd)
            raise
        cmd('x', '-y', '-o%s' % dest, self._iso)

    @contextlib.contextmanager
    def mount(self):
        tmpmnt = tempfile.mkdtemp()
        print 'sudo mount %s %s -o loop' % (self._iso, tmpmnt)
        sh.sudo.mount(self._iso, tmpmnt, '-o', 'loop', _fg=True)
        try:
            yield tmpmnt
        finally:
            print 'sudo umount %s' % tmpmnt
            sh.sudo.umount(tmpmnt, _fg=True)
        shutil.rmtree(tmpmnt)


def create_iso(filename, build_dir):
    print 'packing iso %s' % filename
    sh.find(build_dir, '-type', 'd', '-exec', 'chmod', '755', '{}', ';')
    sh.find(build_dir, '-type', 'f', '-exec', 'chmod', '644', '{}', ';')
    iso_builder(
        '-o',
        filename,
        '-b', 'isolinux/isolinux.bin',
        '-c', 'isolinux/boot.cat',
        '-no-emul-boot',
        '-boot-load-size', '4',
        '-boot-info-table',
        '-J',
        '-R',
        '-V', 'Red Hat Enterprise Linux Atomic',
        build_dir)


def generate_tokens(build_dir, service_accounts=None):
    """
    Generates security tokens for k8s installations

    Operating on a given build_dir, this function generates tokens for
    a kubernetes installation given some assumptions. The calling code is
    implemented in pure python so that the isobuilder can continue to be
    usable from anywhere on the file system. Embedding shell scripts in a
    python package is problematic as there are no real facilities for calling
    non-python scripts."""

    output_path = os.path.join(build_dir, OUTPUT_DIR, "ssl/")

    token_file = os.path.join(output_path, "known_tokens.csv")

    service_accounts = service_accounts or ["default"]
    with open(token_file, 'w') as token_stream:
        for account in service_accounts:
            token = base64.b64encode(os.urandom(128))[:32]
            token_stream.write("{},{},{}\n".format(token, account, account))

            account_token_file = os.path.join(output_path,
                                              "{}.token".format(account))
            with open(account_token_file, 'w') as account_stream:
                account_stream.write("{}\n".format(token))


def generate_certs(build_dir):
    """
    Generates certificates for k8s installations

    Operating on a given build_dir, this function generates certificates for
    a kubernetes installation given some assumptions. The calling code is
    implemented in pure python so that the isobuilder can continue to be
    usable from anywhere on the file system. Embedding shell scripts in a
    python package is problematic as there are no real facilities for calling
    non-python scripts."""

    output_path = os.path.join(build_dir, OUTPUT_DIR, "ssl/")

    path_to = lambda f: os.path.join(output_path, f)
    cmd_context = {
        "cert_days": 10000,
        "key_complexity": 2048,
        "subject": "/CN=localhost",
        "config": path_to("openssl.conf"),
        "ca_key": path_to("ca.key"),
        "ca_crt": path_to("ca.crt"),
        "server_key": path_to("server.key"),
        "server_csr": path_to("server.csr"),
        "server_crt": path_to("server.crt")
    }

    cmds = [
        "genrsa -out {ca_key} {key_complexity}",
        "req -x509 -new -nodes -key {ca_key} -config {config} -days "
            "{cert_days} -subj {subject} -out {ca_crt}",
        "genrsa -out {server_key} {key_complexity}",
        "req -new -key {server_key} -out {server_csr} -subj {subject}",
        "x509 -req -in {server_csr} -CA {ca_crt} -CAkey {ca_key} "
            "-CAcreateserial -out {server_crt} -days {cert_days} "
            "-extensions v3_req -extfile {config}"
    ]
    for cmd in cmds:
        openssl(*[c.format(**cmd_context) for c in cmd.split(' ')])

    for p in ["ca_key", "ca_crt", "server_key", "server_csr", "server_crt"]:
        os.chmod(cmd_context[p], stat.S_IRGRP | stat.S_IRUSR)


@click.command()
@click.argument('base_iso', type=click.Path(exists=True))
@click.argument('config', type=click.Path(exists=True))
def make_iso(base_iso, config):
    iso = ISO(base_iso)
    new_iso_dir = tempfile.mkdtemp()
    try:
        iso.copy_to(new_iso_dir)
    except sh.CommandNotFound:
        shutil.rmtree(new_iso_dir)
        sys.exit(1)

    # templates dir is relative to make_iso
    templates = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates')
    tw = TemplateWriter(config, templates)
    config_dir = tw.write_templates()

    generate_certs(config_dir)
    generate_tokens(config_dir)

    # NOTE All things one desires to be in an ISO must be created before
    #      the copy below
    # copy over overlay files
    sh.cp('-r', glob.glob('%s/*' % config_dir), new_iso_dir)

    # output iso is based on input iso and config
    input_info = 'unattended-%s' % os.path.basename(config).strip('.yaml')
    output_iso = '%s-%s' % (input_info, os.path.basename(base_iso))
    if 'installer' in base_iso:
        output_iso = os.path.basename(base_iso).replace('installer', input_info)

    create_iso(os.path.join(config_dir, output_iso), new_iso_dir)

    # cleanup
    click.echo('rm -rf %s' % new_iso_dir)
    sh.rm('-rf', new_iso_dir, _fg=True)

    click.echo('iso and overlay files in %s' % config_dir)


if __name__ == '__main__':
    make_iso()
