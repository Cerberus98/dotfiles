#
# Copyright 2017, Cisco Systems
# All Rights Reserved.
#

import base64
import datetime
import errno
import os
import random
import string
import paramiko
import sqlalchemy

from tranquility import app
from tranquility import db
from tranquility import log
from tranquility.api import models


def ssh_user_exists(username):
    path = os.path.join(app.config['SSH_KEY_DIR'], username)
    # os.path.getmtime is used instead of os.path.exists, because the latter won't error on permission issues.
    try:
        os.path.getmtime(path)
    except OSError as e:
        if e.errno == errno.ENOENT:
            return False
        elif e.errno == errno.EACCES:
            log.error('Permission denied reading "%s".', path)
            return False
        raise
    return True


def get_user_keys(username):
    authorized_key_file = os.path.join(app.config['SSH_KEY_DIR'], username)
    keys = []

    try:
        for line in open(authorized_key_file).readlines():
            parts = line.split()
            if len(parts) < 2:
                log.error('Malformed line "%s" in %s.', line, authorized_key_file)
                continue
            if parts[0] == 'ssh-rsa':
                data = base64.b64decode(parts[1])
                keys.append(paramiko.RSAKey(data=data))
            elif parts[0] == 'ssh-dss':
                data = base64.b64decode(parts[1])
                keys.append(paramiko.DSSKey(data=data))
            else:
                log.error('Unsupported key type "%s" in %s.', parts[0], authorized_key_file)

    except IOError as e:
        log.error('Error reading %s: %s', authorized_key_file, os.strerror(e.errno))
        return None

    return keys


def ensure_user(username):
    # Since we create a db entry for the user on login, it's possible that a new user would try and login twice
    # at the exact same time, triggering two simultaneous creates.  Due to this, we have to be a bit careful.
    user = models.User.query.filter_by(username=username).first()
    if user:
        return user

    user = models.User(username)
    try:
        db.session.add(user)
        db.session.commit()
    except sqlalchemy.exc.IntegrityError as e:
        log.warning('Detected user creation race for %s, attempting re-query.', username)
        if 'UNIQUE constraint failed: user.username' in str(e):
            db.session.rollback()
            user = models.User.query.filter_by(username=username).first()
            if not user:
                # If the user still doesn't exist, something other than a simple duplication happened.
                log.warning('Requery failed.  This is the error: %s.', str(e))
                raise
            log.warning('Requery successful.')

    return user


def cleanup_challenges():
    older_than = datetime.datetime.utcnow() - datetime.timedelta(seconds=models.CHALLENGE_EXPIRE)
    # = is added here to make tests run faster.
    db.session.query(models.Challenge).filter(models.Challenge.created <= older_than).delete()
    db.session.commit()


def new_challenge(username):
    challenge = ''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits) \
        for _ in range(models.CHALLENGE_LEN))

    if not ssh_user_exists(username):
        # Since authentication hasn't been completed at this point, don't leak that the user isn't valid.
        return challenge

    user = ensure_user(username)

    challenge_m = models.Challenge(user.id, challenge)
    db.session.add(challenge_m)
    db.session.commit()

    return challenge


def verify_challenge(username, challenge, signatures):
    challenge_m = models.Challenge.query.filter_by(challenge=challenge).first()
    if not challenge_m:
        return None

    user = models.User.query.filter_by(username=username).first()

    if challenge_m.user_id != user.id:
        return None

    keys = get_user_keys(username)
    if not keys:
        return None

    db.session.delete(challenge_m)
    db.session.commit()

    log.critical("C" * 80)
    log.critical(keys)
    log.critical("C" * 80)
    for signature in signatures:
        for key in keys:
            if key.verify_ssh_sig(challenge, paramiko.Message(signature)):
                return user

    return None
